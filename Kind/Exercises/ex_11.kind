// ListMap Exercises

type ListMap <A: Type> { 
  empty
  cons(head: Pair<Nat, A>, tail: ListMap<A>)
}

// Inserts a value
// If the key is already present, its value is updated
// If the key is not present, the value is added to the map
set<A: Type>(key: Nat, value: A, lm: ListMap<A>): ListMap<A>
  case lm {
    empty: ListMap.cons<A>(Pair.new<Nat, A>(key, value), ListMap.empty<A>)
    cons:  open lm.head
           case Nat.eql(key, lm.head.fst) {
              true: ListMap.cons<A>(Pair.new<Nat, A>(key, value), lm.tail)
              false: ListMap.cons<A>(lm.head, set<A>(key, value, lm.tail))
              }
  }

//ListMap.cons<A>(Pair.new<A>(0, 0), ListMap.cons<A>(Pair.new<A>(1, 1), ListMap.cons<A>(Pair.new<A>(2, 2), ListMap.empty<A>)
// Primeiro tentativa nao deu muito certo, eu me enrolei e desisti desse caminho
  // case lm {
  //   empty: ListMap.empty<A>
  //   cons:  case lm.head {
  //     new: case lm.head.tail {
  //       empty: case Nat.eql(lm.head, key) {
  //         true:  ListMap.cons<A>(
  //         false: ListMap.cons<A>(Pair.new<A>(key, value), List.concat<A>(lm.head, acum)
  //       }
  //       cons: 
  //     }
      
  //       case Nat.eql(lm.head.fst, key){
  //       true:  ListMap.cons<A>(Pair.new(key, value), List.concat(acum, lm.tail)
  //       false: set_go<A>(key, value, lm.tail, List.concat(lm.head, acum))

  //     }
  //   }
  // }

// Returns a Value from a Key
// If the key is not present, returns None
get<A: Type>(key: Nat, lm: ListMap<A>): Maybe<A>
  case lm {
    empty: Maybe.none<A>
    cons: open lm.head 
          case Nat.eql(key, lm.head.fst) {
            true:  Maybe.some<A>(lm.head.snd)
            false: get<A>(key, lm.tail)
            }
  }

// Applies a function to a Value from a Key
// Returns the same ListMap if the key is not present 
mut<A: Type>(key: Nat, fn: A -> A, lm: ListMap<A>): ListMap<A>
  case lm {
    empty: ListMap.empty<A>
    cons:  
        open lm.head
        case Nat.eql(key, lm.head.fst) {
          true: ListMap.cons<A>(Pair.new<Nat, A>(lm.head.fst, fn(lm.head.snd)), lm.tail)
          false: ListMap.cons<A>(lm.head, mut<A>(key, fn, lm.tail))
          }
  }

// Converts the ListMap to a String
show<A: Type>(fn: A -> String, lm: ListMap<A>): String
  case lm {
    empty: String.nil
    cons: case lm.head {
      new: String.concat(fn(lm.head.snd), show<A>(fn, lm.tail))
    }
  }

// Checks if the ListMap has a key
// Returns true if the key is present, false otherwise
has<A:Type>(key: Nat, lm: ListMap<A>): Bool
  case lm {
    empty: Bool.false
    cons: open lm.head
          case Nat.eql(key, lm.head.fst) {
            true: Bool.true
            false: has<A>(key, lm.tail)
          }
  }

// Removes all Elements that doesn't satisfy a condition
filter<A: Type>(cond: A -> Bool, lm: ListMap<A>): ListMap<A>
  case lm {
    empty: ListMap.empty<A>
    cons: open lm.head 
          case cond(lm.head.snd) {
            true:  ListMap.cons<A>(lm.head, filter<A>(cond, lm.tail))
            false: filter<A>(cond, lm.tail)
          }
  }

// Applies a function to all Values
map<A: Type, B: Type>(fn: A -> B, lm: ListMap<A>): ListMap<B>
  case lm {
    empty: ListMap.empty<B>
    cons:  
          open lm.head
          ListMap.cons<B>(Pair.new<Nat, B>(lm.head.fst, fn(lm.head.snd)), map<A, B>(fn, lm.tail))
  }


stress_test(sets: Nat, gets: Nat): IO<Unit>
  Tests.stress.lmap(sets, gets)

ex_11: IO<Unit>
  IO {
    Tests._11.set(set)
    Tests._11.get(get)
    Tests._11.mut(mut)
    Tests._11.has(has)
    Tests._11.filter(filter)
    Tests._11.map(map)
  } 
